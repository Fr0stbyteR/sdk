{
  "version": 3,
  "sources": ["../node_modules/@webaudiomodules/api/src/AbstractWebAudioModule.js", "../src/WebAudioModule.js", "../src/WamParameterInfo.js", "../src/RingBuffer.js", "../src/WamEventRingBuffer.js", "../src/WamNode.js"],
  "sourcesContent": ["/** @typedef {import('./types').WamDescriptor} IWamDescriptor */\n/** @typedef {import('./types').WamNode} IWamNode */\n/** @typedef {import('./types').WebAudioModule} IWebAudioModule */\n\n/**\n * WebAudioModule v2 Main Class API,\n * see d.ts file for more information.\n * @abstract\n * @implements {IWebAudioModule}\n */\nexport default class WebAudioModule {\n\tstatic get isWebAudioModuleConstructor() { throw new Error('Not Implemented.'); return null; }\n\n\tstatic async createInstance(audioContext, initialState) { throw new Error('Not Implemented.'); return null; }\n\n\tconstructor(audioContext) {}\n\n\tget isWebAudioModule() { throw new Error('Not Implemented.'); return null; }\n\n\tget audioContext() { throw new Error('Not Implemented.'); return null; }\n\tset audioContext(audioContext) { throw new Error('Not Implemented.'); }\n\n\tget audioNode() { throw new Error('Not Implemented.'); return null; }\n\tset audioNode(audioNode) { throw new Error('Not Implemented.'); }\n\n\tget initialized() { throw new Error('Not Implemented.'); return null; }\n\tset initialized(initialized) { throw new Error('Not Implemented.'); }\n\n\tget moduleId() { throw new Error('Not Implemented.'); return null; }\n\n\tget instanceId() { throw new Error('Not Implemented.'); return null; }\n\tset instanceId(instanceId) { throw new Error('Not Implemented.'); }\n\n\tget descriptor() { throw new Error('Not Implemented.'); return null; }\n\n\tget name() { throw new Error('Not Implemented.'); return null; }\n\n\tget vendor() { throw new Error('Not Implemented.'); return null; }\n\n\tasync initialize(state) { throw new Error('Not Implemented.'); return null; }\n\n\tasync createAudioNode(initialState) { throw new Error('Not Implemented.'); return null; }\n\n\tasync createGui() { throw new Error('Not Implemented.'); return null; }\n\n\tdestroyGui(gui) { throw new Error('Not Implemented.'); }\n}\n", "/** @typedef {import('@webaudiomodules/api').WamDescriptor} WamDescriptor */\n/** @typedef {import('@webaudiomodules/api').WamNode} WamNode */\n\nimport AbstractWebAudioModule from '@webaudiomodules/api/src/AbstractWebAudioModule.js';\n\nclass WebAudioModule extends AbstractWebAudioModule {\n\tstatic get isWebAudioModuleConstructor() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {BaseAudioContext} audioContext\n\t * @param {any} [initialState]\n\t * @returns {Promise<AbstractWebAudioModule<any>>}\n\t */\n\tstatic createInstance(audioContext, initialState) {\n\t\treturn new this(audioContext).initialize(initialState);\n\t}\n\n\t/** @param {BaseAudioContext} audioContext */\n\tconstructor(audioContext) {\n\t\tsuper(audioContext);\n\t\tthis._audioContext = audioContext;\n\t\tthis._initialized = false;\n\t\t/** @type {WamNode} */\n\t\tthis._audioNode = undefined;\n\t\tthis._timestamp = performance.now();\n\t\t/**\n\t\t * Url to load the plugin's GUI HTML\n\t\t * @type {string}\n\t\t */\n\t\tthis._guiModuleUrl = undefined;\n\t\t/**\n\t\t * Url to load the plugin's `descriptor.json`\n\t\t * @type {string}\n\t\t */\n\t\tthis._descriptorUrl = './descriptor.json';\n\t\t/** @type {WamDescriptor} */\n\t\tthis._descriptor = {\n\t\t\tname: `WebAudioModule_${this.constructor.name}`,\n\t\t\tvendor: 'WebAudioModuleVendor',\n\t\t\tdescription: '',\n\t\t\tversion: '0.0.0',\n\t\t\tsdkVersion: '1.0.0',\n\t\t\tthumbnail: '',\n\t\t\tkeywords: [],\n\t\t\tisInstrument: false,\n\t\t\twebsite: '',\n\t\t\thasAudioInput: true,\n\t\t\thasAudioOutput: true,\n\t\t\thasAutomationInput: true,\n\t\t\thasAutomationOutput: true,\n\t\t\thasMidiInput: true,\n\t\t\thasMidiOutput: true,\n\t\t\thasMpeInput: true,\n\t\t\thasMpeOutput: true,\n\t\t\thasOscInput: true,\n\t\t\thasOscOutput: true,\n\t\t\thasSysexInput: true,\n\t\t\thasSysexOutput: true,\n\t\t};\n\t}\n\n\tget isWebAudioModule() {\n\t\treturn true;\n\t}\n\n\tget moduleId() { return this.vendor + this.name; }\n\n\tget instanceId() { return this.moduleId + this._timestamp; }\n\n\tget descriptor() { return this._descriptor; }\n\n\tget name() { return this.descriptor.name; }\n\n\tget vendor() { return this.descriptor.vendor; }\n\n\tget audioContext() {\n\t\treturn this._audioContext;\n\t}\n\n\tget audioNode() {\n\t\tif (!this.initialized) console.warn('WAM should be initialized before getting the audioNode');\n\t\treturn this._audioNode;\n\t}\n\n\tset audioNode(node) {\n\t\tthis._audioNode = node;\n\t}\n\n\tget initialized() {\n\t\treturn this._initialized;\n\t}\n\n\tset initialized(value) {\n\t\tthis._initialized = value;\n\t}\n\n\t/**\n\t * @param {any} [initialState]\n\t * @returns {Promise<WamNode>}\n\t */\n\tasync createAudioNode(initialState) {\n\t\t// should return a subclass of WamNode\n\t\tthrow new TypeError('createAudioNode() not provided');\n\t}\n\n\t/**\n\t * @param {any} [state]\n\t * @returns {Promise<WebAudioModule>}\n\t */\n\tasync initialize(state) {\n\t\t// await this._loadDescriptor();\n\t\tif (!this._audioNode) this.audioNode = await this.createAudioNode();\n\t\tthis.initialized = true;\n\t\treturn this;\n\t}\n\n\tasync _loadGui() {\n\t\tconst url = this._guiModuleUrl;\n\t\tif (!url) throw new TypeError('Gui module not found');\n\t\t// @ts-ignore\n\t\treturn import(/* webpackIgnore: true */url);\n\t}\n\n\tasync _loadDescriptor() {\n\t\tconst url = this._descriptorUrl;\n\t\tif (!url) throw new TypeError('Descriptor not found');\n\t\tconst response = await fetch(url);\n\t\tconst descriptor = await response.json();\n\t\tObject.assign(this._descriptor, descriptor);\n\t\treturn this._descriptor;\n\t}\n\n\t/**\n\t * @returns {Promise<HTMLElement>}\n\t */\n\tasync createGui() {\n\t\tif (!this.initialized) console.warn('Plugin should be initialized before getting the gui');\n\t\t// Do not fail if no gui is present, just return undefined\n\t\tif (!this._guiModuleUrl) return undefined;\n\t\tconst { createElement } = await this._loadGui();\n\t\treturn createElement(this);\n\t}\n\n\tdestroyGui() {}\n}\n\nexport default WebAudioModule;\n", "/** @typedef {import('@webaudiomodules/api').WamParameterInfo} IWamParameterInfo */\n/** @typedef {import('@webaudiomodules/api').WamParameterType} WamParameterType */\n/** @typedef {import('@webaudiomodules/api').WamParameterConfiguration} WamParameterConfiguration */\n\n/**\n * @param {number} x\n * @param {number} e\n */\nconst normExp = (x, e) => (e === 0 ? x : x ** (1.5 ** -e));\n\n/**\n * @param {number} x\n * @param {number} e\n */\nconst denormExp = (x, e) => (e === 0 ? x : x ** (1.5 ** e));\n\n/**\n * @param {number} x\n * @param {number} min\n * @param {number} max\n */\nconst normalize = (x, min, max, e = 0) => (\n\tmin === 0 && max === 1\n\t\t? normExp(x, e)\n\t\t: normExp((x - min) / (max - min) || 0, e));\n\n/**\n * @param {any} x\n * @param {number} min\n * @param {number} max\n */\nconst denormalize = (x, min, max, e = 0) => (\n\tmin === 0 && max === 1\n\t\t? denormExp(x, e)\n\t\t: denormExp(x, e) * (max - min) + min\n);\n\n/**\n * @param {number} x\n * @param {number} min\n * @param {number} max\n */\nconst inRange = (x, min, max) => (x >= min && x <= max);\n\n/**\n * @implements {IWamParameterInfo}\n */\nexport default class WamParameterInfo {\n\t/**\n\t * @param {string} id\n\t * @param {WamParameterConfiguration} [config]\n\t */\n\tconstructor(id, config = {}) {\n\t\tlet {\n\t\t\ttype, label, defaultValue, minValue, maxValue, discreteStep, exponent, choices, units,\n\t\t} = config;\n\t\tif (type === undefined) type = 'float';\n\t\tif (label === undefined) label = '';\n\t\tif (defaultValue === undefined) defaultValue = 0;\n\t\tif (choices === undefined) choices = [];\n\t\tif (type === 'boolean' || type === 'choice') {\n\t\t\tdiscreteStep = 1;\n\t\t\tminValue = 0;\n\t\t\tif (choices.length) maxValue = choices.length - 1;\n\t\t\telse maxValue = 1;\n\t\t} else {\n\t\t\tif (minValue === undefined) minValue = 0;\n\t\t\tif (maxValue === undefined) maxValue = 1;\n\t\t\tif (discreteStep === undefined) discreteStep = 0;\n\t\t\tif (exponent === undefined) exponent = 0;\n\t\t\tif (units === undefined) units = '';\n\t\t}\n\n\t\tconst errBase = `Param config error | ${id}: `;\n\t\tif (minValue >= maxValue) throw Error(errBase.concat('minValue must be less than maxValue'));\n\t\tif (!inRange(defaultValue, minValue, maxValue)) throw Error(errBase.concat('defaultValue out of range'));\n\t\tif (discreteStep % 1 || discreteStep < 0) {\n\t\t\tthrow Error(errBase.concat('discreteStep must be a non-negative integer'));\n\t\t} else if (discreteStep > 0 && (minValue % 1 || maxValue % 1 || defaultValue % 1)) {\n\t\t\tthrow Error(errBase.concat('non-zero discreteStep requires integer minValue, maxValue, and defaultValue'));\n\t\t}\n\t\tif (type === 'choice' && !choices.length) {\n\t\t\tthrow Error(errBase.concat('choice type parameter requires list of strings in choices'));\n\t\t}\n\n\t\t/**\n\t\t * The parameter's unique identifier.\n\t\t * @readonly @type {string}\n\t\t */\n\t\tthis.id = id;\n\n\t\t/**\n\t\t * The parameter's human-readable name.\n\t\t * @readonly @type {string}\n\t\t */\n\t\tthis.label = label;\n\n\t\t/**\n\t\t * The parameter's data type.\n\t\t * @readonly @type {WamParameterType}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * The parameter's default value. Must be\n\t\t * within range `[minValue, maxValue]`.\n\t\t * @readonly @type {number}\n\t\t */\n\t\tthis.defaultValue = defaultValue;\n\n\t\t/**\n\t\t * The minimum valid value of the parameter's range.\n\t\t * @readonly @type {number}\n\t\t */\n\t\tthis.minValue = minValue;\n\n\t\t/**\n\t\t * The maximum valid value of the parameter's range.\n\t\t * @readonly @type {number}\n\t\t */\n\t\tthis.maxValue = maxValue;\n\n\t\t/**\n\t\t * The distance between adjacent valid integer\n\t\t * values, if applicable.\n\t\t * @readonly @type {number}\n\t\t */\n\t\tthis.discreteStep = discreteStep;\n\n\t\t/**\n\t\t * The nonlinear (exponential) skew of the parameter's\n\t\t * range, if applicable.\n\t\t *  @readonly @type {number}\n\t\t */\n\t\tthis.exponent = exponent;\n\n\t\t/**\n\t\t * A list of human-readable choices corresponding to each\n\t\t * valid integer value in the parameter's range, if applicable.\n\t\t * @readonly @type {string[]}\n\t\t */\n\t\tthis.choices = choices;\n\n\t\t/**\n\t\t * A human-readable string representing the units of the\n\t\t * parameter's range, if applicable.\n\t\t * @readonly @type {string}\n\t\t */\n\t\tthis.units = units;\n\t}\n\n\t/**\n\t * Convert a value from the parameter's denormalized range\n\t * `[minValue, maxValue]` to normalized range `[0, 1]`.\n\t * @param {number} value\n\t */\n\tnormalize(value) {\n\t\treturn normalize(value, this.minValue, this.maxValue, this.exponent);\n\t}\n\n\t/**\n\t * Convert a value from normalized range `[0, 1]` to the\n\t * parameter's denormalized range `[minValue, maxValue]`.\n\t * @param {number} valueNorm\n\t */\n\tdenormalize(valueNorm) {\n\t\treturn denormalize(valueNorm, this.minValue, this.maxValue, this.exponent);\n\t}\n\n\t/**\n\t * Get a human-readable string representing the given value,\n\t * including units if applicable.\n\t * @param {number} value\n\t */\n\tvalueString(value) {\n\t\tif (this.choices) return this.choices[value];\n\t\tif (this.units !== '') return `${value} ${this.units}`;\n\t\treturn `${value}`;\n\t}\n}\n\nif (globalThis.AudioWorkletGlobalScope) {\n\tglobalThis.WamParameterInfo = WamParameterInfo;\n}\n", "/** @typedef {import('./types').TypedArrayConstructor} TypedArrayConstructor */\n/** @typedef {import('./types').TypedArray} TypedArray */\n/** @typedef {import('./types').RingBuffer} IRingBuffer */\n/** @typedef {typeof import('./types').RingBuffer} RingBufferConstructor */\n/** @typedef {import('./types').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n\n/**\n * @returns {RingBufferConstructor}\n */\nconst executable = () => {\n\t/**\n\t * A Single Producer - Single Consumer thread-safe wait-free ring buffer.\n\t * The producer and the consumer can be on separate threads, but cannot change roles,\n\t * except with external synchronization. Adapted from https://github.com/padenot/ringbuf.js\n\t * MPL-2.0 License (see RingBuffer_LICENSE.txt)\n\t *\n\t * @implements {IRingBuffer}\n\t * @author padenot\n\t */\n\tclass RingBuffer {\n\t\t/**\n\t\t * @param {number} capacity\n\t\t * @param {TypedArrayConstructor} Type\n\t\t */\n\t\tstatic getStorageForCapacity(capacity, Type) {\n\t\t\tif (!Type.BYTES_PER_ELEMENT) {\n\t\t\t\tthrow new Error('Pass in a ArrayBuffer subclass');\n\t\t\t}\n\t\t\tconst bytes = 8 + (capacity + 1) * Type.BYTES_PER_ELEMENT;\n\t\t\treturn new SharedArrayBuffer(bytes);\n\t\t}\n\n\t\t/**\n\t\t * `sab` is a SharedArrayBuffer with a capacity calculated by calling\n\t\t * `getStorageForCapacity` with the desired capacity.\n\t\t *\n\t\t * @param {SharedArrayBuffer} sab\n\t\t * @param {TypedArrayConstructor} Type\n\t\t */\n\t\tconstructor(sab, Type) {\n\t\t\t// eslint-disable-next-line no-prototype-builtins\n\t\t\tif (!Type.BYTES_PER_ELEMENT) {\n\t\t\t\tthrow new Error('Pass a concrete typed array class as second argument');\n\t\t\t}\n\n\t\t\t// Maximum usable size is 1<<32 - type.BYTES_PER_ELEMENT bytes in the ring\n\t\t\t// buffer for this version, easily changeable.\n\t\t\t// -4 for the write ptr (uint32_t offsets)\n\t\t\t// -4 for the read ptr (uint32_t offsets)\n\t\t\t// capacity counts the empty slot to distinguish between full and empty.\n\t\t\tthis._Type = Type;\n\t\t\tthis._capacity = (sab.byteLength - 8) / Type.BYTES_PER_ELEMENT;\n\t\t\tthis.buf = sab;\n\t\t\tthis.write_ptr = new Uint32Array(this.buf, 0, 1);\n\t\t\tthis.read_ptr = new Uint32Array(this.buf, 4, 1);\n\t\t\tthis.storage = new Type(this.buf, 8, this._capacity);\n\t\t}\n\n\t\t/**\n\t\t * Returns the type of the underlying ArrayBuffer for this RingBuffer. This\n\t\t * allows implementing crude type checking.\n\t\t */\n\t\tget type() {\n\t\t\treturn this._Type.name;\n\t\t}\n\n\t\t/**\n\t\t * Push bytes to the ring buffer. `elements` is a typed array of the same type\n\t\t * as passed in the ctor, to be written to the queue.\n\t\t * Returns the number of elements written to the queue.\n\t\t *\n\t\t * @param {TypedArray} elements\n\t\t */\n\t\tpush(elements) {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\n\t\t\tif ((wr + 1) % this._storageCapacity() === rd) {\n\t\t\t\t// full\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst toWrite = Math.min(this._availableWrite(rd, wr), elements.length);\n\t\t\tconst firstPart = Math.min(this._storageCapacity() - wr, toWrite);\n\t\t\tconst secondPart = toWrite - firstPart;\n\n\t\t\tthis._copy(elements, 0, this.storage, wr, firstPart);\n\t\t\tthis._copy(elements, firstPart, this.storage, 0, secondPart);\n\n\t\t\t// publish the enqueued data to the other side\n\t\t\tAtomics.store(\n\t\t\t\tthis.write_ptr,\n\t\t\t\t0,\n\t\t\t\t(wr + toWrite) % this._storageCapacity(),\n\t\t\t);\n\n\t\t\treturn toWrite;\n\t\t}\n\n\t\t/**\n\t\t * Read `elements.length` elements from the ring buffer if `elements` is a typed\n\t\t * array of the same type as passed in the ctor. If `elements` is an integer,\n\t\t * pop and discard that many elements from the ring buffer.\n\t\t * Returns the number of elements read from the queue, they are placed at the\n\t\t * beginning of the array passed as parameter if `elements` is not an integer.\n\t\t *\n\t\t * @param {TypedArray | number} elements\n\t\t */\n\t\tpop(elements) {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\n\t\t\tif (wr === rd) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst isArray = !Number.isInteger(elements);\n\t\t\t// @ts-ignore\n\t\t\tconst toRead = Math.min(this._availableRead(rd, wr), isArray ? elements.length : elements);\n\n\t\t\tif (isArray) {\n\t\t\t\tconst firstPart = Math.min(this._storageCapacity() - rd, toRead);\n\t\t\t\tconst secondPart = toRead - firstPart;\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis._copy(this.storage, rd, elements, 0, firstPart);\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis._copy(this.storage, 0, elements, firstPart, secondPart);\n\t\t\t}\n\t\t\tAtomics.store(this.read_ptr, 0, (rd + toRead) % this._storageCapacity());\n\n\t\t\treturn toRead;\n\t\t}\n\n\t\t/**\n\t\t * True if the ring buffer is empty false otherwise. This can be late on the\n\t\t * reader side: it can return true even if something has just been pushed.\n\t\t */\n\t\tget empty() {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\n\t\t\treturn wr === rd;\n\t\t}\n\n\t\t/**\n\t\t * True if the ring buffer is full, false otherwise. This can be late on the\n\t\t * write side: it can return true when something has just been popped.\n\t\t */\n\t\tget full() {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\n\t\t\treturn (wr + 1) % this._capacity !== rd;\n\t\t}\n\n\t\t/**\n\t\t * The usable capacity for the ring buffer: the number of elements that can be\n\t\t * stored.\n\t\t */\n\t\tget capacity() {\n\t\t\treturn this._capacity - 1;\n\t\t}\n\n\t\t/**\n\t\t * Number of elements available for reading. This can be late, and report less\n\t\t * elements that is actually in the queue, when something has just been\n\t\t * enqueued.\n\t\t */\n\t\tget availableRead() {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\t\t\treturn this._availableRead(rd, wr);\n\t\t}\n\n\t\t/**\n\t\t * Number of elements available for writing. This can be late, and report less\n\t\t * elements that is actually available for writing, when something has just\n\t\t * been dequeued.\n\t\t */\n\t\tget availableWrite() {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\t\t\treturn this._availableWrite(rd, wr);\n\t\t}\n\n\t\t// private methods //\n\n\t\t/**\n\t\t * Number of elements available for reading, given a read and write pointer..\n\t\t *\n\t\t * @param {number} rd\n\t\t * @param {number} wr\n\t\t */\n\t\t_availableRead(rd, wr) {\n\t\t\tif (wr > rd) {\n\t\t\t\treturn wr - rd;\n\t\t\t}\n\t\t\treturn wr + this._storageCapacity() - rd;\n\t\t}\n\n\t\t/**\n\t\t * Number of elements available from writing, given a read and write pointer.\n\t\t *\n\t\t * @param {number} rd\n\t\t * @param {number} wr\n\t\t */\n\t\t_availableWrite(rd, wr) {\n\t\t\tlet rv = rd - wr - 1;\n\t\t\tif (wr >= rd) {\n\t\t\t\trv += this._storageCapacity();\n\t\t\t}\n\t\t\treturn rv;\n\t\t}\n\n\t\t/**\n\t\t * The size of the storage for elements not accounting the space for the index.\n\t\t */\n\t\t_storageCapacity() {\n\t\t\treturn this._capacity;\n\t\t}\n\n\t\t/**\n\t\t * Copy `size` elements from `input`, starting at offset `offset_input`, to\n\t\t * `output`, starting at offset `offset_output`.\n\t\t *\n\t\t * @param {TypedArray} input\n\t\t * @param {number} offsetInput\n\t\t * @param {TypedArray} output\n\t\t * @param {number} offsetOutput\n\t\t * @param {number} size\n\t\t */\n\t\t_copy(input, offsetInput, output, offsetOutput, size) {\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\toutput[offsetOutput + i] = input[offsetInput + i];\n\t\t\t}\n\t\t}\n\t}\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\tif (!audioWorkletGlobalScope.RingBuffer) audioWorkletGlobalScope.RingBuffer = RingBuffer;\n\t}\n\n\treturn RingBuffer;\n};\n/** @type {AudioWorkletGlobalScope} */\n// @ts-ignore\nconst audioWorkletGlobalScope = globalThis;\nif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\tif (!audioWorkletGlobalScope.RingBuffer) executable();\n}\n\nexport default executable;\n\n/* Usage in main thread:\nimport executable from 'RingBuffer.js';\nconst RingBuffer = executable();\n*/\n\n/* Usage in audio thread:\n// in main thread:\naudioWorklet.addModule('RingBuffer.js');\n// in audio thread\nconst { RingBuffer } = globalThis;\n*/\n\n/* Usage in audio thread with a build system:\n// in main thread:\nimport executable from 'RingBuffer.js';\nconst blob = new Blob([`(${executable.toString()})();`], { type: 'text/javascript' })\nconst url = window.URL.createObjectURL(blob);\naudioWorklet.addModule(url);\n// in audio thread\nconst { RingBuffer } = globalThis;\n*/\n", "/** @typedef {import('@webaudiomodules/api').WamEvent} WamEvent */\n/** @typedef {import('@webaudiomodules/api').WamEventType} WamEventType */\n/** @typedef {import('@webaudiomodules/api').WamAutomationEvent} WamAutomationEvent */\n/** @typedef {import('@webaudiomodules/api').WamTransportEvent} WamTransportEvent */\n/** @typedef {import('@webaudiomodules/api').WamMidiEvent} WamMidiEvent */\n/** @typedef {import('@webaudiomodules/api').WamSysexEvent} WamSysexEvent */\n/** @typedef {import('@webaudiomodules/api').WamMpeEvent} WamMpeEvent */\n/** @typedef {import('@webaudiomodules/api').WamOscEvent} WamOscEvent */\n/** @typedef {import('@webaudiomodules/api').WamInfoEvent} WamInfoEvent */\n/** @typedef {import('@webaudiomodules/api').WamParameterData} WamParameterData */\n/** @typedef {import('@webaudiomodules/api').WamTransportData} WamTransportData */\n/** @typedef {import('@webaudiomodules/api').WamMidiData} WamMidiData */\n/** @typedef {import('@webaudiomodules/api').WamBinaryData} WamBinaryData */\n/** @typedef {import('@webaudiomodules/api').WamInfoData} WamInfoData */\n/** @typedef {typeof import('./types').RingBuffer} RingBufferConstructor */\n/** @typedef {import('./types').RingBuffer} RingBuffer */\n/** @typedef {import('./types').TypedArrayConstructor} TypedArrayConstructor */\n/** @typedef {import('./types').WamEventRingBuffer} IWamEventRingBuffer */\n/** @typedef {typeof import('./types').WamEventRingBuffer} WamEventRingBufferConstructor */\n/** @typedef {import('./types').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n\n/**\n * @returns {WamEventRingBufferConstructor}\n */\nconst executable = () => {\n\t/**\n\t * @implements {IWamEventRingBuffer}\n\t */\n\tclass WamEventRingBuffer {\n\n\t\t/**\n\t\t * Default number of additional bytes allocated\n\t\t * per event (to support variable-size event objects)\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic DefaultExtraBytesPerEvent = 64;\n\n\t\t/**\n\t\t * Number of bytes required for WamEventBase\n\t\t * {uint32} total event size in bytes\n\t\t * {uint8} encoded event type\n\t\t * {float64} time\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamEventBaseBytes = 4 + 1 + 8;\n\n\t\t/**\n\t\t * Number of bytes required for WamAutomationEvent\n\t\t * {WamEventBaseBytes} common event properties\n\t\t * {uint16} encoded parameter id\n\t\t * {float64} value\n\t\t * {uint8} normalized\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamAutomationEventBytes = WamEventRingBuffer.WamEventBaseBytes + 2 + 8 + 1;\n\n\t\t/**\n\t\t * Number of bytes required for WamTransportEvent\n\t\t * {WamEventBaseBytes} common event properties\n\t\t * {uint32} current bar\n\t\t * {float64} currentBarStarted\n\t\t * {float64} tempo\n\t\t * {uint8} time signature numerator\n\t\t * {uint8} time signature denominator\n\t\t * {uint8} playing flag\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamTransportEventBytes = WamEventRingBuffer.WamEventBaseBytes + 4 + 8 + 8 + 1 + 1 + 1;\n\n\t\t/**\n\t\t * Number of bytes required for WamMidiEvent or WamMpeEvent\n\t\t * {WamEventBaseBytes} common event properties\n\t\t * {uint8} status byte\n\t\t * {uint8} data1 byte\n\t\t * {uint8} data2 byte\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamMidiEventBytes = WamEventRingBuffer.WamEventBaseBytes + 1 + 1 + 1;\n\n\t\t/**\n\t\t * Number of bytes required for WamSysexEvent or WamOscEvent\n\t\t * (total number depends on content of message / size of byte array)\n\t\t * {WamEventBaseBytes} common event properties\n\t\t * {uint32} number of bytes in binary array\n\t\t * {uint8[]} N bytes in binary array depending on message\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamBinaryEventBytes = WamEventRingBuffer.WamEventBaseBytes + 4; // + N\n\n\t\t/**\n\t\t * Returns a SharedArrayBuffer large enough to safely store\n\t\t * the specified number of events. Specify 'maxBytesPerEvent'\n\t\t * to support variable-size binary event types like sysex or osc.\n\t\t *\n\t\t * @param {RingBufferConstructor} RingBuffer\n\t\t * @param {number} eventCapacity\n\t\t * @param {number} [maxBytesPerEvent=undefined]\n\t\t * @returns {SharedArrayBuffer}\n\t\t */\n\t\tstatic getStorageForEventCapacity(RingBuffer, eventCapacity, maxBytesPerEvent = undefined) {\n\t\t\tif (maxBytesPerEvent === undefined) maxBytesPerEvent = WamEventRingBuffer.DefaultExtraBytesPerEvent;\n\t\t\telse maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer.DefaultExtraBytesPerEvent);\n\t\t\tconst capacity = (Math.max(\n\t\t\t\tWamEventRingBuffer.WamAutomationEventBytes,\n\t\t\t\tWamEventRingBuffer.WamTransportEventBytes,\n\t\t\t\tWamEventRingBuffer.WamMidiEventBytes,\n\t\t\t\tWamEventRingBuffer.WamBinaryEventBytes,\n\t\t\t) + maxBytesPerEvent) * eventCapacity;\n\t\t\treturn RingBuffer.getStorageForCapacity(capacity, Uint8Array);\n\t\t}\n\n\t\t/**\n\t\t * Provides methods for encoding / decoding WamEvents to / from\n\t\t * a UInt8Array RingBuffer. Specify 'maxBytesPerEvent'\n\t\t * to support variable-size binary event types like sysex or osc.\n\t\t *\n\t\t * @param {RingBufferConstructor} RingBuffer\n\t\t * @param {SharedArrayBuffer} sab\n\t\t * @param {string[]} parameterIds\n\t\t * @param {number} [maxBytesPerEvent=undefined]\n\t\t */\n\t\tconstructor(RingBuffer, sab, parameterIds, maxBytesPerEvent = undefined) {\n\t\t\t/** @type {Record<string, number>} */\n\t\t\tthis._eventSizeBytes = {};\n\n\t\t\t/** @type {Record<string, number>} */\n\t\t\tthis._encodeEventType = {};\n\n\t\t\t/** @type {Record<number, string>} */\n\t\t\tthis._decodeEventType = {};\n\t\t\t/** @type {WamEventType[]} */\n\t\t\tconst wamEventTypes = ['wam-automation', 'wam-transport', 'wam-midi', 'wam-sysex', 'wam-mpe', 'wam-osc', 'wam-info'];\n\t\t\twamEventTypes.forEach((type, encodedType) => {\n\t\t\t\tlet byteSize = 0;\n\t\t\t\tswitch (type) {\n\t\t\t\tcase 'wam-automation': byteSize = WamEventRingBuffer.WamAutomationEventBytes; break;\n\t\t\t\tcase 'wam-transport': byteSize = WamEventRingBuffer.WamTransportEventBytes; break;\n\t\t\t\tcase 'wam-mpe':\n\t\t\t\tcase 'wam-midi': byteSize = WamEventRingBuffer.WamMidiEventBytes; break;\n\t\t\t\tcase 'wam-osc':\n\t\t\t\tcase 'wam-sysex':\n\t\t\t\tcase 'wam-info': byteSize = WamEventRingBuffer.WamBinaryEventBytes; break;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t\tthis._eventSizeBytes[type] = byteSize;\n\t\t\t\tthis._encodeEventType[type] = encodedType;\n\t\t\t\tthis._decodeEventType[encodedType] = type;\n\t\t\t});\n\n\t\t\t/** @type {number} */\n\t\t\tthis._parameterCode = 0;\n\t\t\t/** @type {{[parameterId: string]: number}} */\n\t\t\tthis._parameterCodes = {};\n\t\t\t/** @type {{[parameterId: string]: number}} */\n\t\t\tthis._encodeParameterId = {};\n\t\t\t/** @type {{[parameterId: number]: string}} */\n\t\t\tthis._decodeParameterId = {};\n\t\t\tthis.setParameterIds(parameterIds);\n\n\t\t\t/** @type {SharedArrayBuffer} */\n\t\t\tthis._sab = sab;\n\n\t\t\tif (maxBytesPerEvent === undefined) maxBytesPerEvent = WamEventRingBuffer.DefaultExtraBytesPerEvent;\n\t\t\telse maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer.DefaultExtraBytesPerEvent);\n\n\t\t\t/** @type {number} */\n\t\t\tthis._eventBytesAvailable = Math.max(\n\t\t\t\tWamEventRingBuffer.WamAutomationEventBytes,\n\t\t\t\tWamEventRingBuffer.WamTransportEventBytes,\n\t\t\t\tWamEventRingBuffer.WamMidiEventBytes,\n\t\t\t\tWamEventRingBuffer.WamBinaryEventBytes,\n\t\t\t) + maxBytesPerEvent;\n\t\t\t/** @type {ArrayBuffer} */\n\t\t\tthis._eventBytes = new ArrayBuffer(this._eventBytesAvailable);\n\t\t\t/** @type {DataView} */\n\t\t\tthis._eventBytesView = new DataView(this._eventBytes);\n\n\t\t\t/** @type {RingBuffer} */\n\t\t\tthis._rb = new RingBuffer(this._sab, Uint8Array);\n\n\t\t\t/** @type {Uint8Array} */\n\t\t\tthis._eventSizeArray = new Uint8Array(this._eventBytes, 0, 4);\n\n\t\t\t/** @type {DataView} */\n\t\t\tthis._eventSizeView = new DataView(this._eventBytes, 0, 4);\n\t\t}\n\n\t\t/**\n\t\t * Write common WamEvent properties to internal buffer.\n\t\t *\n\t\t * @private\n\t\t * @param {number} byteSize total size of event in bytes\n\t\t * @param {string} type\n\t\t * @param {number} time\n\t\t * @returns {number} updated byte offset\n\t\t */\n\t\t_writeHeader(byteSize, type, time) {\n\t\t\tlet byteOffset = 0;\n\t\t\tthis._eventBytesView.setUint32(byteOffset, byteSize);\n\t\t\tbyteOffset += 4;\n\t\t\tthis._eventBytesView.setUint8(byteOffset, this._encodeEventType[type]);\n\t\t\tbyteOffset += 1;\n\t\t\tthis._eventBytesView.setFloat64(byteOffset, Number.isFinite(time) ? time : -1);\n\t\t\tbyteOffset += 8;\n\t\t\treturn byteOffset;\n\t\t}\n\n\t\t/**\n\t\t * Write WamEvent to internal buffer.\n\t\t *\n\t\t * @private\n\t\t * @param {WamEvent} event\n\t\t * @returns {Uint8Array}\n\t\t */\n\t\t_encode(event) {\n\t\t\tlet byteOffset = 0;\n\t\t\tconst { type, time } = event;\n\t\t\tswitch (event.type) {\n\t\t\tcase 'wam-automation': {\n\t\t\t\tif (!(event.data.id in this._encodeParameterId)) break;\n\t\t\t\tconst byteSize = this._eventSizeBytes[type];\n\t\t\t\tbyteOffset = this._writeHeader(byteSize, type, time);\n\n\t\t\t\t/**\n\t\t\t\t * @type {WamAutomationEvent}\n\t\t\t\t * @property {WamAutomationData} data\n\t\t\t\t */\n\t\t\t\tconst { data } = event;\n\t\t\t\tconst encodedParameterId = this._encodeParameterId[data.id];\n\t\t\t\tconst { value, normalized } = data;\n\n\t\t\t\tthis._eventBytesView.setUint16(byteOffset, encodedParameterId);\n\t\t\t\tbyteOffset += 2;\n\t\t\t\tthis._eventBytesView.setFloat64(byteOffset, value);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tthis._eventBytesView.setUint8(byteOffset, normalized ? 1 : 0);\n\t\t\t\tbyteOffset += 1;\n\t\t\t} break;\n\t\t\tcase 'wam-transport': {\n\t\t\t\tconst byteSize = this._eventSizeBytes[type];\n\t\t\t\tbyteOffset = this._writeHeader(byteSize, type, time);\n\n\t\t\t\t/**\n\t\t\t\t * @type {WamTransportEvent}\n\t\t\t\t * @property {WamTransportData} data\n\t\t\t\t */\n\t\t\t\tconst { data } = event;\n\t\t\t\tconst {\n\t\t\t\t\tcurrentBar, currentBarStarted, tempo, timeSigNumerator, timeSigDenominator, playing\n\t\t\t\t} = data;\n\n\t\t\t\tthis._eventBytesView.setUint32(byteOffset, currentBar);\n\t\t\t\tbyteOffset += 4;\n\t\t\t\tthis._eventBytesView.setFloat64(byteOffset, currentBarStarted);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tthis._eventBytesView.setFloat64(byteOffset, tempo);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tthis._eventBytesView.setUint8(byteOffset, timeSigNumerator);\n\t\t\t\tbyteOffset += 1;\n\t\t\t\tthis._eventBytesView.setUint8(byteOffset, timeSigDenominator);\n\t\t\t\tbyteOffset += 1;\n\t\t\t\tthis._eventBytesView.setUint8(byteOffset, playing ? 1 : 0);\n\t\t\t\tbyteOffset += 1;\n\t\t\t} break;\n\t\t\tcase 'wam-mpe':\n\t\t\tcase 'wam-midi': {\n\t\t\t\tconst byteSize = this._eventSizeBytes[type];\n\t\t\t\tbyteOffset = this._writeHeader(byteSize, type, time);\n\n\t\t\t\t/**\n\t\t\t\t * @type {WamMidiEvent | WamMpeEvent}\n\t\t\t\t * @property {WamMidiData} data\n\t\t\t\t */\n\t\t\t\tconst { data } = event;\n\t\t\t\tconst { bytes } = data;\n\t\t\t\tlet b = 0;\n\t\t\t\twhile (b < 3) {\n\t\t\t\t\tthis._eventBytesView.setUint8(byteOffset, bytes[b]);\n\t\t\t\t\tbyteOffset += 1;\n\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t} break;\n\t\t\tcase 'wam-osc':\n\t\t\tcase 'wam-sysex':\n\t\t\tcase 'wam-info': {\n\t\t\t\t/** @type {Uint8Array | null} */\n\t\t\t\tlet bytes = null;\n\t\t\t\tif (event.type === 'wam-info') {\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {WamInfoEvent}\n\t\t\t\t\t * @property {WamInfoData} data\n\t\t\t\t\t */\n\t\t\t\t\tconst { data } = event;\n\t\t\t\t\tbytes = (new TextEncoder()).encode(data.instanceId);\n\t\t\t\t} else {\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {WamSysexEvent | WamOscEvent}\n\t\t\t\t\t * @property {WamBinaryData} data\n\t\t\t\t\t */\n\t\t\t\t\tconst { data } = event;\n\t\t\t\t\tbytes = data.bytes;\n\t\t\t\t}\n\t\t\t\tconst numBytes = bytes.length;\n\t\t\t\tconst byteSize = this._eventSizeBytes[type];\n\t\t\t\tbyteOffset = this._writeHeader(byteSize + numBytes, type, time);\n\n\t\t\t\tthis._eventBytesView.setUint32(byteOffset, numBytes);\n\t\t\t\tbyteOffset += 4;\n\n\t\t\t\tconst bytesRequired = byteOffset + numBytes;\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tif (bytesRequired > this._eventBytesAvailable) console.error(`Event requires ${bytesRequired} bytes but only ${this._eventBytesAvailable} have been allocated!`);\n\n\t\t\t\tconst buffer = new Uint8Array(this._eventBytes, byteOffset, numBytes);\n\t\t\t\tbuffer.set(bytes);\n\t\t\t\tbyteOffset += numBytes;\n\t\t\t} break;\n\t\t\tdefault: break;\n\t\t\t}\n\t\t\treturn new Uint8Array(this._eventBytes, 0, byteOffset);\n\t\t}\n\n\t\t/**\n\t\t * Read WamEvent from internal buffer.\n\t\t *\n\t\t * @private\n\t\t * @returns {WamEvent | false} Decoded WamEvent\n\t\t */\n\t\t_decode() {\n\t\t\tlet byteOffset = 0;\n\t\t\tconst type = this._decodeEventType[this._eventBytesView.getUint8(byteOffset)];\n\t\t\tbyteOffset += 1;\n\t\t\tlet time = this._eventBytesView.getFloat64(byteOffset);\n\t\t\tif (time === -1) time = undefined;\n\t\t\tbyteOffset += 8;\n\n\t\t\tswitch (type) {\n\t\t\tcase 'wam-automation': {\n\t\t\t\tconst encodedParameterId = this._eventBytesView.getUint16(byteOffset);\n\t\t\t\tbyteOffset += 2;\n\t\t\t\tconst value = this._eventBytesView.getFloat64(byteOffset);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tconst normalized = !!this._eventBytesView.getUint8(byteOffset);\n\t\t\t\tbyteOffset += 1;\n\n\t\t\t\tif (!(encodedParameterId in this._decodeParameterId)) break;\n\t\t\t\tconst id = this._decodeParameterId[encodedParameterId];\n\t\t\t\t/** @type {WamAutomationEvent} */\n\t\t\t\tconst event = {\n\t\t\t\t\ttype,\n\t\t\t\t\ttime,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tid, value, normalized,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tcase 'wam-transport': {\n\t\t\t\tconst currentBar = this._eventBytesView.getUint32(byteOffset);\n\t\t\t\tbyteOffset += 4;\n\t\t\t\tconst currentBarStarted = this._eventBytesView.getFloat64(byteOffset);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tconst tempo = this._eventBytesView.getFloat64(byteOffset);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tconst timeSigNumerator = this._eventBytesView.getUint8(byteOffset);\n\t\t\t\tbyteOffset += 1;\n\t\t\t\tconst timeSigDenominator = this._eventBytesView.getUint8(byteOffset);\n\t\t\t\tbyteOffset += 1;\n\t\t\t\tconst playing = (this._eventBytesView.getUint8(byteOffset) == 1);\n\t\t\t\tbyteOffset += 1;\n\n\t\t\t\t/** @type {WamTransportEvent} */\n\t\t\t\tconst event = {\n\t\t\t\t\ttype,\n\t\t\t\t\ttime,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcurrentBar, currentBarStarted, tempo, timeSigNumerator, timeSigDenominator, playing\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tcase 'wam-mpe':\n\t\t\tcase 'wam-midi': {\n\t\t\t\t/** @type {[number, number, number]} */\n\t\t\t\tconst bytes = [0, 0, 0];\n\t\t\t\tlet b = 0;\n\t\t\t\twhile (b < 3) {\n\t\t\t\t\tbytes[b] = this._eventBytesView.getUint8(byteOffset);\n\t\t\t\t\tbyteOffset += 1;\n\t\t\t\t\tb++;\n\t\t\t\t}\n\n\t\t\t\t/** @type {WamMidiEvent | WamMpeEvent} */\n\t\t\t\tconst event = {\n\t\t\t\t\ttype,\n\t\t\t\t\ttime,\n\t\t\t\t\tdata: { bytes },\n\t\t\t\t};\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tcase 'wam-osc':\n\t\t\tcase 'wam-sysex':\n\t\t\tcase 'wam-info': {\n\t\t\t\tconst numBytes = this._eventBytesView.getUint32(byteOffset);\n\t\t\t\tbyteOffset += 4;\n\t\t\t\tconst bytes = new Uint8Array(numBytes);\n\t\t\t\tbytes.set(new Uint8Array(this._eventBytes, byteOffset, numBytes));\n\t\t\t\tbyteOffset += numBytes;\n\n\t\t\t\tif (type === 'wam-info') {\n\t\t\t\t\tconst instanceId = (new TextDecoder()).decode(bytes);\n\t\t\t\t\tconst data = { instanceId };\n\t\t\t\t\treturn { type, time, data };\n\t\t\t\t} else {\n\t\t\t\t\tconst data = { bytes };\n\t\t\t\t\treturn { type, time, data };\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault: break;\n\t\t\t}\n\t\t\t// eslint-disable-next-line no-console\n\t\t\t// console.warn('Failed to decode event!');\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * Write WamEvents to the ring buffer, returning\n\t\t * the number of events successfully written.\n\t\t *\n\t\t * @param {WamEvent[]} events\n\t\t * @returns {number}\n\t\t */\n\t\twrite(...events) {\n\t\t\tconst numEvents = events.length;\n\t\t\tlet bytesAvailable = this._rb.availableWrite;\n\t\t\tlet numSkipped = 0;\n\t\t\tlet i = 0;\n\t\t\twhile (i < numEvents) {\n\t\t\t\tconst event = events[i];\n\t\t\t\tconst bytes = this._encode(event);\n\t\t\t\tconst eventSizeBytes = bytes.byteLength;\n\n\t\t\t\tlet bytesWritten = 0;\n\t\t\t\tif (bytesAvailable >= eventSizeBytes) {\n\t\t\t\t\tif (eventSizeBytes === 0) numSkipped++;\n\t\t\t\t\telse bytesWritten = this._rb.push(bytes);\n\t\t\t\t} else break;\n\t\t\t\tbytesAvailable -= bytesWritten;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn i - numSkipped;\n\t\t}\n\n\t\t/**\n\t\t * Read WamEvents from the ring buffer, returning\n\t\t * the list of events successfully read.\n\t\t *\n\t\t * @returns {WamEvent[]}\n\t\t */\n\t\tread() {\n\t\t\tif (this._rb.empty) return [];\n\t\t\tconst events = [];\n\t\t\tlet bytesAvailable = this._rb.availableRead;\n\t\t\tlet bytesRead = 0;\n\t\t\twhile (bytesAvailable > 0) {\n\t\t\t\tbytesRead = this._rb.pop(this._eventSizeArray);\n\t\t\t\tbytesAvailable -= bytesRead;\n\t\t\t\tconst eventSizeBytes = this._eventSizeView.getUint32(0);\n\t\t\t\tconst eventBytes = new Uint8Array(this._eventBytes, 0, eventSizeBytes - 4);\n\t\t\t\tbytesRead = this._rb.pop(eventBytes);\n\t\t\t\tbytesAvailable -= bytesRead;\n\t\t\t\tconst decodedEvent = this._decode();\n\t\t\t\tif (decodedEvent) events.push(decodedEvent);\n\t\t\t}\n\t\t\treturn events;\n\t\t}\n\n\t\t/**\n\t\t * In case parameter set changes, update the internal mappings.\n\t\t * May result in some invalid automation events, which will be\n\t \t * ignored. Note that this must be called on all corresponding\n\t\t * WamEventRingBuffers on both threads.\n\t\t * @param {string[]} parameterIds\n\t\t */\n\t\tsetParameterIds(parameterIds) {\n\t\t\tthis._encodeParameterId = {};\n\t\t\tthis._decodeParameterId = {};\n\t\t\tparameterIds.forEach((parameterId) => {\n\t\t\t\tlet parameterCode = -1\n\t\t\t\tif (parameterId in this._parameterCodes) parameterCode = this._parameterCodes[parameterId];\n\t\t\t\telse {\n\t\t\t\t\tparameterCode = this._generateParameterCode();\n\t\t\t\t\tthis._parameterCodes[parameterId] = parameterCode;\n\t\t\t\t}\n\t\t\t\tthis._encodeParameterId[parameterId] = parameterCode;\n\t\t\t\tthis._decodeParameterId[parameterCode] = parameterId;\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Generates a numeric parameter code in a range suitable for\n\t\t * encoding as uint16.\n\t\t *\n\t\t * @returns {number}\n\t\t */\n\t\t_generateParameterCode() {\n\t\t\tif (this._parameterCode > 65535) throw Error('Too many parameters have been registered!');\n\t\t\treturn this._parameterCode++;\n\t\t}\n\n\t}\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\tif (!audioWorkletGlobalScope.WamEventRingBuffer) {\n\t\t\taudioWorkletGlobalScope.WamEventRingBuffer = WamEventRingBuffer;\n\t\t}\n\t}\n\n\treturn WamEventRingBuffer;\n};\n/** @type {AudioWorkletGlobalScope} */\n// @ts-ignore\nconst audioWorkletGlobalScope = globalThis;\nif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\tif (!audioWorkletGlobalScope.WamEventRingBuffer) executable();\n}\n\nexport default executable;\n", "/** @typedef {import('@webaudiomodules/api').WamNode} IWamNode */\n/** @typedef {import('@webaudiomodules/api').WebAudioModule} WebAudioModule */\n/** @typedef {import('@webaudiomodules/api').WamParameterInfoMap} WamParameterInfoMap */\n/** @typedef {import('@webaudiomodules/api').WamParameterDataMap} WamParameterDataMap */\n/** @typedef {import('@webaudiomodules/api').WamEvent} WamEvent */\n/** @typedef {import('@webaudiomodules/api').WamEventType} WamEventType */\n/** @typedef {import('./types').WamEventRingBuffer} WamEventRingBuffer */\n\nimport getRingBuffer from './RingBuffer.js';\nimport getWamEventRingBuffer from './WamEventRingBuffer.js';\n\nconst RingBuffer = getRingBuffer();\nconst WamEventRingBuffer = getWamEventRingBuffer();\n\n/**\n * @implements {IWamNode}\n */\nexport default class WamNode extends AudioWorkletNode {\n\t/**\n\t * Register scripts required for the processor. Must be called before constructor.\n\t * @param {BaseAudioContext} audioContext\n\t * @param {string} baseURL\n\t */\n\tstatic async addModules(audioContext, baseURL) {\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/RingBuffer.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamEventRingBuffer.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamArrayRingBuffer.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamEnv.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamParameter.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamParameterInfo.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamParameterInterpolator.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamProcessor.js`);\n\t}\n\n\t/**\n\t * @param {WebAudioModule} module\n\t * @param {AudioWorkletNodeOptions} options\n\t */\n\tconstructor(module, options) {\n\t\tconst { audioContext, moduleId, instanceId } = module;\n\t\toptions.processorOptions = {\n\t\t\tmoduleId,\n\t\t\tinstanceId,\n\t\t\t...options.processorOptions,\n\t\t};\n\t\tsuper(audioContext, moduleId, options);\n\n\t\t/** @type {WebAudioModule} */\n\t\tthis.module = module;\n\t\t/** @private @type {Set<WamEventType>} */\n\t\tthis._supportedEventTypes = new Set(['wam-automation', 'wam-transport', 'wam-midi', 'wam-sysex', 'wam-mpe', 'wam-osc']);\n\t\t/** @private @type {number} */\n\t\tthis._messageId = 1;\n\t\t/** @private @type {Record<number, (...args: any[]) => any>} */\n\t\tthis._pendingResponses = {};\n\t\t/** @private @type {Record<number, () => any>} */\n\t\tthis._pendingEvents = {};\n\t\t/** @private @type {boolean} */\n\t\tthis._useSab = false; // can override this via processorOptions;\n\t\t/** @private @type {boolean} */\n\t\tthis._eventSabReady = false;\n\t\t/** @private @type {boolean} */\n\t\tthis._destroyed = false;\n\n\t\tthis.port.onmessage = this._onMessage.bind(this);\n\t}\n\n\t/** @returns {string} */\n\tget moduleId() { return this.module.moduleId; }\n\t/** @returns {string} */\n\tget instanceId() { return this.module.instanceId; }\n\t/** @returns {string} */\n\tget processorId() { return this.moduleId; }\n\n\t/**\n\t * Get parameter info for the specified parameter ids,\n\t * or omit argument to get info for all parameters.\n\t * @param {string[]} parameterIds\n\t * @returns {Promise<WamParameterInfoMap>}\n\t */\n\tasync getParameterInfo(...parameterIds) {\n\t\tconst request = 'get/parameterInfo';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { parameterIds },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get parameter values for the specified parameter ids,\n\t * or omit argument to get values for all parameters.\n\t * @param {boolean} normalized\n\t * @param {string[]} parameterIds\n\t * @returns {Promise<WamParameterDataMap>}\n\t */\n\tasync getParameterValues(normalized, ...parameterIds) {\n\t\tconst request = 'get/parameterValues';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { normalized, parameterIds },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Set parameter values for the specified parameter ids.\n\t * @param {WamParameterDataMap} parameterValues\n\t * @returns {Promise<void>}\n\t */\n\tasync setParameterValues(parameterValues) {\n\t\tconst request = 'set/parameterValues';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { parameterValues },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Returns an object (such as JSON or a serialized blob)\n\t * that can be used to restore the WAM's state.\n\t * @returns {Promise<any>}\n\t */\n\tasync getState() {\n\t\tconst request = 'get/state';\n\t\t// perhaps the only info to request from processor is param state?\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({ id, request });\n\t\t});\n\t}\n\n\t/**\n\t * Use an object (such as JSON or a serialized blob)\n\t * to restore the WAM's state.\n\t * @param {any} state\n\t */\n\tasync setState(state) {\n\t\tconst request = 'set/state';\n\t\tconst id = this._generateMessageId();\n\t\t// perhaps the only info to send to processor is param state?\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { state },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Compensation delay hint in seconds.\n\t * @returns {Promise<number>}\n\t */\n\tasync getCompensationDelay() {\n\t\tconst request = 'get/compensationDelay';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({ id, request });\n\t\t});\n\t}\n\n\t/**\n\t * Register a callback function so it will be called\n\t * when matching events are processed.\n\t * @param {WamEventType} type\n\t * @param {EventListenerOrEventListenerObject | null} callback\n\t * @param {AddEventListenerOptions | boolean} options;\n\t */\n\taddEventListener(type, callback, options) {\n\t\tif (this._supportedEventTypes.has(type)) super.addEventListener(type, callback, options);\n\t}\n\n\t/**\n\t * Deregister a callback function so it will no longer\n\t * be called when matching events are processed.\n\t * @param {WamEventType} type\n\t * @param {EventListenerOrEventListenerObject | null} callback\n\t * @param {AddEventListenerOptions | boolean} options;\n\t */\n\tremoveEventListener(type, callback, options) {\n\t\tif (this._supportedEventTypes.has(type)) super.removeEventListener(type, callback, options);\n\t}\n\n\t/**\n\t * From the main thread, schedule a WamEvent.\n\t * Listeners will be triggered when the event is processed.\n\t * @param {WamEvent[]} events\n\t */\n\tscheduleEvents(...events) {\n\t\tlet i = 0;\n\t\tconst numEvents = events.length;\n\t\tif (this._eventSabReady) {\n\t\t\ti = this._eventWriter.write(...events);\n\t\t\t// fall back on message port if ring buffer gets full\n\t\t}\n\t\twhile (i < numEvents) {\n\t\t\tconst event = events[i];\n\t\t\tconst request = 'add/event';\n\t\t\tconst id = this._generateMessageId();\n\t\t\tlet processed = false;\n\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\t\tthis._pendingEvents[id] = () => { if (!processed) reject(); };\n\t\t\t\tthis.port.postMessage({\n\t\t\t\t\tid,\n\t\t\t\t\trequest,\n\t\t\t\t\tcontent: { event },\n\t\t\t\t});\n\t\t\t}).then((resolved) => {\n\t\t\t\tprocessed = true;\n\t\t\t\tdelete this._pendingEvents[id];\n\t\t\t\tthis._onEvent(event);\n\t\t\t}).catch((rejected) => { delete this._pendingResponses[id]; });\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/** From the main thread, clear all pending WamEvents. */\n\tasync clearEvents() {\n\t\tconst request = 'remove/events';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tconst ids = Object.keys(this._pendingEvents);\n\t\t\tif (ids.length) {\n\t\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\t\tthis.port.postMessage({ id, request });\n\t\t\t}\n\t\t}).then((clearedIds) => {\n\t\t\tclearedIds.forEach((clearedId) => {\n\t\t\t\tthis._pendingEvents[clearedId]();\n\t\t\t\tdelete this._pendingEvents[clearedId];\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {WamNode} to the destination WAM for the event stream\n\t * @param {number} [output] the event output stream of the source WAM\n\t */\n\tconnectEvents(to, output) {\n\t\tif (!to.module?.isWebAudioModule) return;\n\t\tconst request = 'connect/events';\n\t\tconst id = this._generateMessageId();\n\t\tnew Promise((resolve, reject) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { wamInstanceId: to.instanceId, output },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {WamNode} [to] the destination WAM for the event stream\n\t * @param {number} [output]\n\t */\n\tdisconnectEvents(to, output) {\n\t\tif (to && !to.module?.isWebAudioModule) return;\n\t\tconst request = 'disconnect/events';\n\t\tconst id = this._generateMessageId();\n\t\tnew Promise((resolve, reject) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { wamInstanceId: to?.instanceId, output },\n\t\t\t});\n\t\t});\n\t}\n\n\t/** Stop processing and remove the node from the graph. */\n\tdestroy() {\n\t\tif (this._audioToMainInterval) clearInterval(this._audioToMainInterval);\n\t\tthis.port.postMessage({ destroy: true });\n\t\tthis.port.close();\n\t\tthis.disconnect();\n\t\tthis._destroyed = true;\n\t}\n\n\t_generateMessageId() {\n\t\t/* eslint-disable-next-line no-plusplus */\n\t\treturn this._messageId++;\n\t}\n\n\t/**\n\t * Post-constructor (asynchronous) initialization method.\n\t */\n\tasync _initialize() {\n\t\tconst request = 'initialize/processor';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({ id, request });\n\t\t});\n\t}\n\n\t/**\n\t * Messages from audio thread\n\t * @param {MessageEvent} message\n\t * */\n\t_onMessage(message) {\n\t\tconst { data } = message;\n\t\tconst { response, event, eventSab } = data;\n\t\tif (response) {\n\t\t\tconst { id, content } = data;\n\t\t\tconst resolvePendingResponse = this._pendingResponses[id];\n\t\t\tif (resolvePendingResponse) {\n\t\t\t\tdelete this._pendingResponses[id];\n\t\t\t\tresolvePendingResponse(content);\n\t\t\t}\n\t\t\t// else console.log(`unhandled message | response: ${response} content: ${content}`);\n\t\t} else if (eventSab) {\n\t\t\tthis._useSab = true;\n\t\t\tconst { eventCapacity, parameterIds } = eventSab;\n\n\t\t\tif (this._eventSabReady) {\n\t\t\t\t// if parameter set changes after initialization\n\t\t\t\tthis._eventWriter.setParameterIds(parameterIds);\n\t\t\t\tthis._eventReader.setParameterIds(parameterIds);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/** @private @type {SharedArrayBuffer} */\n\t\t\tthis._mainToAudioEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer,\n\t\t\t\teventCapacity);\n\n\t\t\t/** @private @type {SharedArrayBuffer} */\n\t\t\tthis._audioToMainEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer,\n\t\t\t\teventCapacity);\n\n\t\t\t/** @private @type {WamEventRingBuffer} */\n\t\t\tthis._eventWriter = new WamEventRingBuffer(RingBuffer, this._mainToAudioEventSab,\n\t\t\t\tparameterIds);\n\t\t\t/** @private @type {WamEventRingBuffer} */\n\t\t\tthis._eventReader = new WamEventRingBuffer(RingBuffer, this._audioToMainEventSab,\n\t\t\t\tparameterIds);\n\n\t\t\tconst request = 'initialize/eventSab';\n\t\t\tconst id = this._generateMessageId();\n\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\t\tthis.port.postMessage({\n\t\t\t\t\tid,\n\t\t\t\t\trequest,\n\t\t\t\t\tcontent: {\n\t\t\t\t\t\tmainToAudioEventSab: this._mainToAudioEventSab,\n\t\t\t\t\t\taudioToMainEventSab: this._audioToMainEventSab,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}).then((resolved) => {\n\t\t\t\tthis._eventSabReady = true;\n\n\t\t\t\t// periodically check for messages from audio thread\n\t\t\t\tthis._audioToMainInterval = setInterval(() => {\n\t\t\t\t\tconst events = this._eventReader.read();\n\t\t\t\t\tevents.forEach((e) => { this._onEvent(e); });\n\t\t\t\t}, 100);\n\t\t\t});\n\t\t} else if (event) this._onEvent(event);\n\t}\n\n\t_onEvent(event) {\n\t\tconst { type } = event;\n\t\tthis.dispatchEvent(new CustomEvent(type, {\n\t\t\tbubbles: true,\n\t\t\tdetail: event,\n\t\t}));\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
